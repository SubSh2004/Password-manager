import secrets
import string
import os

def rot13(text):
    # Create translation table for ROT13
    return text.translate(str.maketrans("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", 
                                        "NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm"))


filename = "Secret.key"

if os.path.exists(filename):
        # print(f"\nKey Exists in {filename}\n")
        with open(filename, "rb") as file:
              enckey = file.read()
              enckey = enckey.decode()
              enckey = rot13(enckey)
        # print(f"Key: {enckey}\n")

else:
    length = 16
    characters = string.ascii_letters + string.digits + string.punctuation
    key = ''.join(secrets.choice(characters) for _ in range(length))
    # print(f"Key: {key}\n")
    with open(filename , "wb") as file:
        file.write(key.encode())
    # print(f"\nKey is saved in {filename}")
    enckey = key
    with open(filename , "wb") as file:
        key = rot13(key)
        file.write(key.encode())
    # print(f"Key: {enckey}\n")

# Generate a random password
def generate_password():
    length = 10
    characters = string.ascii_letters + string.digits + string.punctuation
    password = ''.join(secrets.choice(characters) for _ in range(length))
    return password
#################################################################################################################################################

#########  Encryption :-  ##########################################


import numpy as np

sBox = [
        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
        ]

        # GF 2^8 {2}
GaloisF2 = [
        0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
        0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
        0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
        0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
        0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
        0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
        0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
        0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
        0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
        0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
        0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
        0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
        0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
        0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
        0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
        0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5
        ]

        # GF 2^8 {3}
GaloisF3 = [
        0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
        0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
        0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
        0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
        0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
        0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
        0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
        0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
        0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
        0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
        0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
        0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
        0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
        0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
        0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
        0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a
        ]

RCON = ["01", "02", "04", "08", "10", "20", "40", "80", "1b", "36"]

   #   Convert string into straight matrix of 2, abcd =  ["ab", "cd"]
def initSteMat(plaintext):
        state = []

        while plaintext:
            state.append(plaintext[:2])    #   append gives "" around character
            plaintext = plaintext[2:]

        return state

    #    XOR operation :- strings xor oper :- ("1a","0f") :- int('0x1a', 0) → 26   int('0x0f', 0) → 15
def xor(left, right): 
        left = ''.join(left)
        right = ''.join(right)

        out = int('0x{}'.format(left), 0) ^ int('0x{}'.format(right), 0)   # 26 ^ 15 = 21
        out = str(hex(out))[2:]    #   hex(21) = 0x15,  0x15[2:1] = 15

        if len(out) < 2:
            out = "0" + out  

        return out

 #  Rotate word function :- 
def rotateWord(word):
        return word[1:] + word[:1] # rotate :- [12 34 56] = [34 56 12]

# Key Schedule 1st part
def SboxMatch(word, round):
        output = []   
        outString = ''

        while word:   # splits word into two two group 
            output.append(word[0:2])
            word = word[2:]

        output = rotateWord(output) 

        for index in range(len(output)):
            out = int("0x{}".format(output[index]), 0)
            out = str(hex(sBox[out]))[2:]

            if len(out) < 2:
                out = "0" + out

            output[index] = out

        output[0] = xor(output[0], RCON[round])

        for char in output:
            outString += char

        return outString

   #  Key schedule part 1
def keySchedule(key, round): # generates key for a specific round
        words = []          # stores input key
        roundKey = [None, None, None, None]  # stores four generated word for round key

        while key:   
            words.append(key[:8])
            key = key[8:]

        roundKey[0] = xor(words[0], SboxMatch(words[3], round)).zfill(8)  # generates different round key words
        roundKey[1] = xor(words[1], roundKey[0]).zfill(8)
        roundKey[2] = xor(words[2], roundKey[1]).zfill(8)
        roundKey[3] = xor(words[3], roundKey[2]).zfill(8)

        return roundKey

# KEY ADDITION
def keyAddition(state, key):
        stateString = ''
        keyString = ''
        newState = []

        for byte in state:   #  concentrate bytes :- if [1a,2b,3c] = 1a2b3c
            stateString += byte

        for word in key: # concentrate strings :- ["12345678","abcdefgh"] = 12345678abcdefgh
            keyString += word
            # print(word)
        stateString = xor(stateString, keyString).zfill(len(stateString))
        # print(stateString)
        while stateString:    #  break state string into 2 character chunk :- 
            newState.append(stateString[:2])  #  state string = "abcdefgh" :- state=[ab], state strings = "bcdefgh"
            stateString = stateString[2:]  #  state = ["ab", "cd"], state string = "efgh"

        return newState

# BYTE Substitution
def byteSubstitution(state):  # substitue bytes from sbox
        newState = []

        for byte in state:
            out = int("0x{}".format(byte), 0)
            out = str(hex(sBox[out]))[2:]

            if len(out) < 2:
                out = "0" + out

            newState.append(out)

        return newState

def shiftRows(state):   # shifts row
        newState = [None for k in range(16)]

        # No Shift
        newState[0], newState[4], newState[8], newState[12] = state[0], state[4], state[8], state[12]

        # First shift. Shift by one
        newState[1], newState[5], newState[9], newState[13] = state[5], state[9], state[13], state[1]

        # Second shift. Shift by two
        newState[2], newState[6], newState[10], newState[14] = state[10], state[14], state[2], state[6]

        # Third shift. Shift by three
        newState[3], newState[7], newState[11], newState[15] = state[15], state[3], state[7], state[11]
        # print(newState)
        return newState

def mixColumn(subState):   #   performs matrix multiplication
        newSubState = []
        currentMultRound = 0

        while len(newSubState) < 4:
            out = int()

            if currentMultRound == 0:
                one = GaloisF2[int("0x{}".format(subState[0]), 0)]
                two = GaloisF3[int("0x{}".format(subState[1]), 0)]
                three = int("0x{}".format(subState[2]), 0)
                four = int("0x{}".format(subState[3]), 0)

                out = one ^ two ^ three ^ four
                # print("0", subState[0],subState[1],subState[2],four,out)
            elif currentMultRound == 1:
                one = int("0x{}".format(subState[0]), 0)
                two = GaloisF2[int("0x{}".format(subState[1]), 0)]
                three = GaloisF3[int("0x{}".format(subState[2]), 0)]
                four = int("0x{}".format(subState[3]), 0)

                out = one ^ two ^ three ^ four
                # print("1", one, two, three, four, out)
            elif currentMultRound == 2:
                one = int("0x{}".format(subState[0]), 0)
                two = int("0x{}".format(subState[1]), 0)
                three = GaloisF2[int("0x{}".format(subState[2]), 0)]
                four = GaloisF3[int("0x{}".format(subState[3]), 0)]

                out = one ^ two ^ three ^ four
                # print("2", one, two, three, four, out)
            else:
                one = GaloisF3[int("0x{}".format(subState[0]), 0)]
                two = int("0x{}".format(subState[1]), 0)
                three = int("0x{}".format(subState[2]), 0)
                four = GaloisF2[int("0x{}".format(subState[3]), 0)]

                out = one ^ two ^ three ^ four
                # print("3", one, two, three, four, out)
            out = str(hex(out))[2:]
            if len(out) < 2:
                out = "0" + out

            newSubState.append(out)
            currentMultRound += 1

        return newSubState

def mixColumns(state):   # performs mixcolumn operation on state matrix
        subState = [] 
        while state:
            subState += mixColumn(state[:4])
            state = state[4:]

        return subState

def encrypt10round(plaintext, key):
    key=str(text_to_number(key, 32))
    # encrypting TEN ROUNDS
    get_all_key = []
    # For first key generation.. Because it added automatically
    get_all_key.append(key)
    state = initSteMat(plaintext)

    # Initial Key Addition Layer
    state = keyAddition(state, key)
    initialise = 1

    for round in range(10):

        state = byteSubstitution(state)
        state = shiftRows(state)

        if round < 9:
            state = mixColumns(state)

        newKey = ""
        for byte in key:
            newKey += byte

        key = newKey
        key = keySchedule(key, round)

        state = keyAddition(state, key)

        pkey = ''.join(map(str, key))
        get_all_key.append(pkey)

        initialise += 1

    return state, get_all_key

#  # Decryption :- 
# Inverse S-Box
invSBox = [
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
]

GaloisF9 = [
    0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x51, 0x5a, 0x63, 0x6c, 0x75, 0x7e, 0x87,
    0x90, 0x99, 0xa2, 0xab, 0xb4, 0xbd, 0xc6, 0xcf, 0xd8, 0xe1, 0xea, 0xf3, 0xfc, 0x05, 0x0e, 0x17,
    0x20, 0x29, 0x32, 0x3b, 0x44, 0x4d, 0x56, 0x5f, 0x68, 0x71, 0x7a, 0x83, 0x8c, 0x95, 0x9e, 0xa7,
    0xb0, 0xb9, 0xc2, 0xcb, 0xd4, 0xdd, 0xe6, 0xef, 0xf8, 0x01, 0x0a, 0x13, 0x1c, 0x25, 0x2e, 0x37,
    0x40, 0x49, 0x52, 0x5b, 0x64, 0x6d, 0x76, 0x7f, 0x88, 0x91, 0x9a, 0xa3, 0xac, 0xb5, 0xbe, 0xc7,
    0xd0, 0xd9, 0xe2, 0xeb, 0xf4, 0xfd, 0x06, 0x0f, 0x18, 0x21, 0x2a, 0x33, 0x3c, 0x45, 0x4e, 0x57,
    0x60, 0x69, 0x72, 0x7b, 0x84, 0x8d, 0x96, 0x9f, 0xa8, 0xb1, 0xba, 0xc3, 0xcc, 0xd5, 0xde, 0xe7,
    0xf0, 0x01, 0x0a, 0x13, 0x1c, 0x25, 0x2e, 0x37, 0x40, 0x49, 0x52, 0x5b, 0x64, 0x6d, 0x76, 0x7f
]

GaloisF11 = [
    0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,
    0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,
    0x60, 0x6b, 0x76, 0x7d, 0x4c, 0x47, 0x5a, 0x51, 0x28, 0x23, 0x3e, 0x35, 0x04, 0x0f, 0x12, 0x19,
    0x90, 0x9b, 0x86, 0x8d, 0xbc, 0xb7, 0xaa, 0xa1, 0xd8, 0xd3, 0xce, 0xc5, 0xf4, 0xff, 0xe2, 0xe9,
    0xc0, 0xcb, 0xd6, 0xdd, 0xec, 0xe7, 0xfa, 0xf1, 0x88, 0x83, 0x9e, 0x95, 0xa4, 0xaf, 0xb2, 0xb9,
    0x71, 0x7a, 0x67, 0x6c, 0x5d, 0x56, 0x4b, 0x40, 0x19, 0x12, 0x0f, 0x04, 0x35, 0x3e, 0x23, 0x28,
    0xa6, 0xad, 0xb0, 0xbb, 0xe3, 0xe8, 0xf5, 0xfe, 0x0b, 0x00, 0x15, 0x1e, 0x2d, 0x26, 0x3b, 0x30,
    0x60, 0x6b, 0x76, 0x7d, 0x4c, 0x47, 0x5a, 0x51, 0x28, 0x23, 0x3e, 0x35, 0x04, 0x0f, 0x12, 0x19
]

GaloisF13 = [
    0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
    0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xa8, 0xa5, 0xb2, 0xbf, 0x9c, 0x91, 0x84, 0x89,
    0x40, 0x4d, 0x58, 0x55, 0x72, 0x7f, 0x6a, 0x67, 0x8e, 0x83, 0x96, 0x9b, 0x58, 0x53, 0x44, 0x49,
    0x60, 0x6d, 0x7a, 0x77, 0x34, 0x39, 0x2a, 0x27, 0x80, 0x8d, 0x9a, 0x97, 0xd4, 0xd9, 0xc8, 0xc5,
    0x28, 0x25, 0x3c, 0x31, 0x56, 0x5b, 0x4e, 0x43, 0x30, 0x3d, 0x28, 0x25, 0x50, 0x5d, 0x4a, 0x47,
    0xe0, 0xed, 0xf8, 0xf5, 0xc2, 0xcf, 0xdc, 0xd1, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
    0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xa8, 0xa5, 0xb2, 0xbf, 0x9c, 0x91, 0x84, 0x89,
    0x40, 0x4d, 0x58, 0x55, 0x72, 0x7f, 0x6a, 0x67, 0x8e, 0x83, 0x96, 0x9b, 0x58, 0x53, 0x44, 0x49
]

GaloisF14 = [
    0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x58, 0x56, 0x44, 0x4a,
    0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0x78, 0x76, 0x64, 0x6a,
    0x80, 0x8e, 0x9c, 0x92, 0xa8, 0xa6, 0xb4, 0xba, 0xd0, 0xde, 0xcc, 0xc2, 0xb8, 0xb6, 0xa4, 0xaa,
    0x20, 0x2e, 0x3c, 0x32, 0x18, 0x16, 0x04, 0x0a, 0x50, 0x5e, 0x4c, 0x42, 0x28, 0x26, 0x34, 0x3a,
    0x40, 0x4e, 0x5c, 0x52, 0x68, 0x66, 0x74, 0x7a, 0xd0, 0xde, 0xcc, 0xc2, 0x58, 0x56, 0x44, 0x4a,
    0xe0, 0xee, 0xfc, 0xf2, 0x78, 0x76, 0x64, 0x6a, 0x90, 0x9e, 0x8c, 0x82, 0xa0, 0xae, 0xbc, 0xb2,
    0x10, 0x1e, 0x2c, 0x22, 0x08, 0x06, 0x14, 0x1a, 0x50, 0x5e, 0x4c, 0x42, 0x38, 0x36, 0x24, 0x2a,
    0x70, 0x7e, 0x6c, 0x62, 0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82
]


def invShiftRows(state):
    newState = [None for _ in range(16)]

    # No Shift
    newState[0], newState[4], newState[8], newState[12] = state[0], state[4], state[8], state[12]

    # First shift. Shift by one (reverse)
    newState[1], newState[5], newState[9], newState[13] = state[13], state[1], state[5], state[9]

    # Second shift. Shift by two (reverse)
    newState[2], newState[6], newState[10], newState[14] = state[10], state[14], state[2], state[6]

    # Third shift. Shift by three (reverse)
    newState[3], newState[7], newState[11], newState[15] = state[7], state[11], state[15], state[3]

    return newState

# Helper function for Galois field multiplication
def galois_multiplication(a, b):
    result = 0
    for _ in range(8):
        if b & 0x01:  # Check if the least significant bit of b is 1
            result ^= a  # XOR with the current value of a
        carry = a & 0x80  # Check if the most significant bit of a is 1
        a = (a << 1) & 0xFF  # Left shift a, ensuring it stays within 8 bits
        if carry:  # If carry is set, XOR with the irreducible polynomial
            a ^= 0x1B
        b >>= 1  # Right shift b
    return result

# Function to apply the inverse mix column transformation on a single column
def inverseMixColumn(subState):
    newSubState = []
    for currentMultRound in range(4):
        if currentMultRound == 0:
            one = galois_multiplication(int(subState[0], 16), 0x0E)
            two = galois_multiplication(int(subState[1], 16), 0x0B)
            three = galois_multiplication(int(subState[2], 16), 0x0D)
            four = galois_multiplication(int(subState[3], 16), 0x09)
        elif currentMultRound == 1:
            one = galois_multiplication(int(subState[0], 16), 0x09)
            two = galois_multiplication(int(subState[1], 16), 0x0E)
            three = galois_multiplication(int(subState[2], 16), 0x0B)
            four = galois_multiplication(int(subState[3], 16), 0x0D)
        elif currentMultRound == 2:
            one = galois_multiplication(int(subState[0], 16), 0x0D)
            two = galois_multiplication(int(subState[1], 16), 0x09)
            three = galois_multiplication(int(subState[2], 16), 0x0E)
            four = galois_multiplication(int(subState[3], 16), 0x0B)
        else:
            one = galois_multiplication(int(subState[0], 16), 0x0B)
            two = galois_multiplication(int(subState[1], 16), 0x0D)
            three = galois_multiplication(int(subState[2], 16), 0x09)
            four = galois_multiplication(int(subState[3], 16), 0x0E)

        newSubState.append(one ^ two ^ three ^ four)
    return [f"{byte:02x}" for byte in newSubState]

def inv_mix_columns(state):  # performs inverse mixcolumn operation on state matrix
    subState = []
    while state:
        subState += inverseMixColumn(state[:4])
        state = state[4:]

    return subState


def invByteSubstitution(state):
    newState = []
    for byte in state:
        out = int("0x{}".format(byte), 0)
        out = str(hex(invSBox[out]))[2:]
        if len(out) < 2:
            out = "0" + out
        newState.append(out)
    return newState

# Corrected decryption function
def decrypt10round(ciphertext, keys):
    state = initSteMat(ciphertext)

    # Reverse rounds
    for round in range(10, 0, -1):
        state = keyAddition(state, keys[round])
        if round < 10:
            state = inv_mix_columns(state)
        state = invShiftRows(state)
        state = invByteSubstitution(state)

    # Final key addition
    state = keyAddition(state, keys[0])

    # Convert state back to plaintext string
    plaintext = ''.join(state)
    plaintext = number_to_text(int(plaintext))
    return plaintext
#---------------------------------------------------------------------------------------------------------------------------

# Example setup

def text_to_number(text, length):
    text = str(text)
    # Convert text to ASCII codes joined as a single number
    ascii_representation = ''.join(str(ord(char)) for char in text)
    # Pad with zeros or truncate to fit the required length
    if len(ascii_representation) < length:
        ascii_representation = ascii_representation.ljust(length, '0')  # Padding
    else:
        ascii_representation = ascii_representation[:length]  # Truncation
    return str(ascii_representation)

def number_to_text(number):
    # Convert the number back to a string to process it
    number_str = str(number)
    text = ''
    i = 0
    
    # Process the string 2-3 digits at a time (typical ASCII code ranges)
    while i < len(number_str):
        # Extract 2 or 3 characters for potential ASCII code
        ascii_code = int(number_str[i:i+2])
        
        # Handle cases where 3 digits are needed (e.g., '116' for 't')
        if ascii_code >= 32 and ascii_code <= 126:
            text += chr(ascii_code)
            i += 2
        else:
            ascii_code = int(number_str[i:i+3])
            text += chr(ascii_code)
            i += 3

    return text

# WEEK 2:-
import sqlite3 # used to create Database
from os.path import join

conn = sqlite3.connect('password.db') # it creates or open a database
cursor = conn.cursor()

## Initialize Database
def initiaDB():
       cursor.execute('''Create Table If Not Exists DATA (Id INTEGER PRIMARY KEY, Site text, Username text, Password text, key0 text, key1 text, key2 text, key3 text, key4 text, key5 text, key6 text, key7 text, key8 text, key9 text, key10 text )''')
       conn.commit()

## Add DATA
def ADDDATA(Site, Username, Password):
       Password = str(text_to_number(Password, 32))
       Password,keys = encrypt10round(Password,enckey)
       ciphertext = ''.join(str(item) for item in Password)
    #    print((ciphertext))
       var0, var1, var2, var3, var4, var5, var6, var7, var8, var9, var10 = keys
       cursor.execute('Insert Into DATA (Site, Username, Password,key0,key1,key2,key3,key4,key5,key6,key7,key8,key9,key10) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
                      (Site,Username,ciphertext,var0, var1, var2, var3, var4, var5, var6, var7, var8, var9, var10 ))
       conn.commit()
       print(f"\nDATA for {Site} added successfully\n")

## Retrieve DATA
def retrieve():
    # Fetch all keys and store them in a dictionary
    cursor.execute('SELECT Id, key0, key1, key2, key3, key4, key5, key6, key7, key8, key9, key10 FROM DATA')
    rows = cursor.fetchall()
    keys_dict = {row[0]: list(row[1:]) for row in rows}

    # Fetch all data entries
    cursor.execute('SELECT Id, Site, Username, Password FROM DATA')
    fetch = cursor.fetchall()

    if not fetch:
        print("\n//---  No DATA STORED  ---//\n")
        Choice()
        return

    # Display stored data
    print("\nStored DATA :- \n")
    for row in fetch:
        print(f"Id {row[0]}  :- \nSite = {row[1]}\nUsername = {row[2]}\n")

    try:
        x = int(input("Enter the Id of the Site you want to retrieve Password \nOr enter 0 to go to main menu: "))
    except ValueError:
        print("\nInvalid input! Returning to main menu.\n")
        Choice()
        return

    if x == 0:
        Choice()
        return

    # Fetch the record for the given ID
    cursor.execute('SELECT Id, Site, Username, Password FROM DATA WHERE Id = ?', (x,))
    row = cursor.fetchone()
    if row:
        print(f"\nID = {row[0]}\nSite = {row[1]}\nUsername = {row[2]}\nPassword stored = {row[3]}\n")
        
        # Retrieve the keys for the selected ID
        if x in keys_dict:
            password = row[3]  # Encrypted password
            keys = keys_dict[x]
            try:
                # Decrypt the password
                decrypted_password = decrypt10round(password, keys)
                print(f"*Actual Password* = {decrypted_password}\n")
            except Exception as e:
                print(f"\nError decrypting password: {e}\n")
        else:
            print(f"\nNo keys found for ID {x}. Decryption not possible.\n")
    else:
        print(f"\n//---  No DATA Stored for ID {x}  ---// \n")

## Delete DATA
def delete():
    cursor.execute('Select Id, Site, Username, Password From DATA')
    fetch = cursor.fetchall()

    if not fetch:
        print("\n//---  No DATA STORED  ---//\n")
        Choice()
        return

    print("\nStored DATA :- \n")
    for row in fetch:
        print(f"Id {row[0]}  :- \nSite = {row[1]}\nUsername = {row[2]}\nEncrypted Password = {row[3]}\n")
    
    try:
        x = int(input("Enter the Id of the Site you want to delete \nOr enter 0 to go to main menu\nOr any other text to exit: "))
    except ValueError:
        print("\nInvalid input! Exiting to main menu.\n")
        Choice()
        return

    if x == 0:
        Choice()
        return

    cursor.execute('DELETE FROM DATA WHERE Id = ?', (x,))
    if cursor.rowcount > 0:
        conn.commit()
        print(f"\nDATA for Id {x} deleted successfully\n")
    else:
        print(f"\n//---  No DATA Stored for ID {x}  ---//\n")
    
    Choice()

            

initiaDB()

def Choice():
    while True:  # Keep the main menu active until the user exits
        print("\n/O/O/O/O----     MAIN MENU       ----O\\O\\O\\O/")
        print("\n 1 to add DATA \n 2 to retrieve DATA \n 3 to delete DATA \n 4 to exit")
        
        try:
            choice = int(input("\nEnter :- "))
        except ValueError:
            print("\nInvalid input. Please enter a valid number (1, 2, 3, or 4).\n")
            continue

        if choice == 1:
            a = input("\nEnter your site :- ")
            b = input("\nEnter your Username :- ")
            x = input("\nDo you want to generate a password ? (y/n) :- ")
            if x.lower() == 'y':
                c = generate_password()
                print(f"\nGenerated Password is :- {c}")
                ADDDATA(a, b, c)
            elif x.lower() == 'n':
                c = input("\nEnter your Password (max 10 characters) :- ")
                if len(c) > 10:
                    print("\nError: Password too long. Please try again.")
                else:
                    ADDDATA(a, b, c)
            else:
                print("\nPlease enter 'y' or 'n'.")
        
        elif choice == 2:
            retrieve()
        
        elif choice == 3:
            delete()
        
        elif choice == 4:
            print("\nYou have successfully Exited\nThank you For Your Stay\n")
            break
        
        else:
            print("\nPlease Enter a Valid Number (1, 2, 3, or 4).\n")

Choice()